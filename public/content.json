{"pages":[{"title":"寒草与前端有场约会🌿","text":"此文分享一个普普通通的程序员的心路历程和一点经验，作为工作一年的纪念作品，也算作我的自我介绍 时间如白驹过隙，回首时已一个春夏秋冬大家好，我是寒草，我是一名在北京已经工作一年的程序猿，我在我们祖国的首都已经度过了一个完整的春夏秋冬，小时候没去过什么外地，一直憧憬着来到北上广去奋斗去闯荡一番自己的天地。 但是真正的来到北京，我们大多数人所经历的并不是那样中二热血的激情岁月，而也是会经历烦恼，压力。但是经历会让人成长，我在北京，我在这里经历，我在这里成长，我在这里经历普通平凡而又与众不同的一天又一天。我来到这里是去年的7月23日，到今天已经完整的一年，这一年里我： 夏日走过朝阳公园的湖畔 秋天满眼都是蓝天白云 冬天漫步在华灯璀璨的街道 春天看到玉渊潭的樱花落英缤纷 又于夏天经历着一次次雷雨突袭 我作为一个前端从业者已经走过完整的一年，有很多经验与故事想与各位读者分享，在此献给大家，献给风华正茂的你们。 所以，接下来让我们进入真正的篇章 寒草呈献我与前端的故事，送给迷茫的你本文作为我的工作一周年经验总结，作为前端从业者，我先讲讲我与前端的故事。 我知道我并不算是一个杰出的前端工程师，未来会不会是我不知道，但是现在的我还差的很远，但是仅仅作为一个普通的前端从业者，我也已经与前端有过一段不长不短的故事了。 我记得是大一那年，我们学校有一个免费的活动，就是可以跟着学习产品或者前端，当然白嫖谁不喜欢，我就选择了前端，跟着上了一段时间，那也算是我前端启蒙了，当然在那里我只是知道了简单的html，css知识。 没错！就是只有html和css知识，当时我和我的小伙伴一起参加的，大家一起用html，css写了一个静态页面，当时最快乐的事情就是和别人说，你看这是我们写的页面，你看这交互，顺滑不顺滑，你看这页面风格，biu 不 beautiful！我想这可能就是影响我最后做了前端的初衷。交互的美由我们亲手实现是多么美好的事情。 其实我也和很多前端聊过这件事情，也有很多前端工程师问过我为什么选择前端，我一直会统一我的回答： “创造美好的东西很有成就感” 我相信也有很多人选择前端也是这样的原因，因为它让我们体验过成就感，虽然我相信做游戏，做动画给我的成就感或许会更大hhh，谁还不是一个热爱游戏的少年呢。 当然这个也是我会积极参与我们commi-ui的原因,我要继续创造美好的东西。 但是很多东西会变的，当时工作半年有一场答辩，leader问我你为什么做前端，我回答依旧是那样，但是接下来的问题我傻了： “可是咱们现在做的页面都是一堆表格表单之类的，没啥美感的时候你的目标又会是什么呢？” 我当时没有答上来，因为这就像是降维打击，我的世界观一下子变了，大家可能不知道我在哪工作，我在某个安全行业的头部企业，hhh，有没有猜到的🐶。不扯皮，我继续说，我当时就感觉一下子有点懵逼，对哈，我现在做的事情和我的初衷感觉不太一样了。这个问题，我也思考了很久呢，看上去甚至是一个影响我从业思想的问题，但是我现在大概想明白了一点： 无论是现在开始写文章也好，还是写一些开源项目也好，我想给这个行业带来更多创造性的东西，我们参与一个行业之后我们可能会感觉它并不是我们想的那样，但是我们会有更多值得我们去做的事情。 不是简单的机械劳作而是我从前端开始我在前端创造 我把真实想法留在了这里，希望有人愿意与我进行思想的碰撞。 走过半载春夏，写作的心路旅程我开始发文章已经半年出头了，虽然我现在肯定是还是一个没啥热度的作者，但是其实写着写着发现，我自己真的感觉到收获很多，无论是为了写出更加精彩的内容而去静心学习的经历，还是因为写文章认识了很多很有趣的朋友。 其实我写文章的初衷可能是觉得在外工作需要一些认同感，所以大家每一次点赞或者评论我都会开心，所以期待大家的点赞 👍 和关注 ➕ 哦，哈哈哈。不仅如此，也是希望通过写文章认识更多的志同道合的同伴，有一起努力的朋友真的很重要。 我反正是推荐每个从业者都去写点东西，目的可以不是让更多人看到（我不是这样哦，我还是希望更多人看到，只是人家不来看罢了嘿嘿嘿），我在这里说一下我觉得写文章做记录的好处吧，从我这半年的体验出发哈： 别人的点赞真的是学习的正反馈，会学习更有积极性的 学会整理总结，有助于提升自己 可以认识一些志同道合的伙伴 锻炼写作能力，虽然我现在文笔也普普通通，但是确实是进步了哈哈哈 当然或许有的大佬真的会打造出属于自己的技术影响力 … 话说我曾经表示过，我很喜欢食梦者这部漫画作品，我觉得纯粹的爱和梦想都是美好的。我也想让我的职业生涯更加纯粹一些，所以呢： 纯粹的职业生涯，从分享写作开始吧～ 奔赴一年轮回，我的经验之谈 此处仅仅代表我的个人观点。 工作中如何交流简洁，明确，直白，省去不必要的环节，该怼就怼，该说就说。 我刚开始工作的时候，真的感觉大家都是大佬，就我一个小菜鸡🐔，很多东西都不敢提，不敢说，怕被笑话，怕被批评。其实这是不对的，不要服务端说啥是啥（当然如果你是服务端或是别的也可以变成不要前端说啥是啥hhh），不要产品说啥就是啥，大家一起工作，有着一致的目标，即使你是萌新，你也有发表想法的权利。 敢于表达会让你在工作中获得更大的主动权。 突然同时有好几个事情要做怎么处理有个东西叫做紧急性重要性四象限，大家可以了解一下，并以统一的维度确立自己的处事风格，我在此表达一下我的理解： 首先，我们明确知道一个点，人可以并发处理问题，而不是并行，遇到很多要解决的事，我们还是要一个一个做的。之后，我们按照事情的紧急程度和重要程度进行排列，一般情况下，紧急程度更加值得关注，我们优先按照紧急程度由高到低去处理问题，同等紧急的事情再去根据重要性和耗时长短去考量事件的优先级。如果事情都不太紧急，再去按照重要性去安排任务。 而且，我眼里，一旦开启一件事情，除非发生难以个人推动的阻塞性问题，或者极其紧急的事情需要处理，就尽量不要中途切换到别的任务。因为事件的切换是需要时间的。 如何解决参会者时间冲突问题这个事情是我有个小伙伴曾经因为邀会问题被训斥了，我思考思考，整理了一下我的想法。 首先，参会者是有优先级的，我们先要去搞清楚，哪些人是必须参会的，哪些人是可以不参加的，之后我们再去优先安排对会议内容更关键的角色的时间，较不重要的参会人可以通过其他方式了解会议结论，比如会议纪要或者讨论内容的相关文档更新记录。 如果工作遇到问题超出自己认知范畴怎么办作为萌新的我们肯定会遇到一些超出自己认知的问题，这种时候其实也是需要一个处理问题的准则。 说白了，这还是个时间问题，我认为，优先解决问题，如果可以快速Google到解决方案，就直接自己解决掉，并记录问题【最好自己有一个markdown】。如果不能，优先去问身边的有经验者或者技术大佬（如果他有时间并愿意搭理你的话），不要把较长工作时间浪费在探索问题原因这件事情上，我眼里这个时间我会控制在一小时，当然如果任务少，我就死磕，任务重时间紧的时候，我看一看就直接暴露，快速找人解决。反正根据任务量，工作紧张程度，去自己衡量一个阈值。留给自己去探索解决问题时间的阈值。但是，最后，我们一定要记录问题！并尽量本周事，本周毕，不要留尾巴，把问题弄清楚，搞明白，这也是提升的过程。 需求混乱，理解困难怎么办大家是不是都经历过这样的情况，项目进展比较混乱，需求没有理顺就开始开发了，或者说刚刚接手一个项目，你压根就不了解需求，结果上来就对需求，有很多不懂的，一脸懵逼。 反正我有过，产品压根讲不清楚需求，或者说他对一些细节还没有确定的答案呢，这一期需求就开始了，这样大家所有人都不去主动的推动需求明确的话，是很危险的！ 当时我们开始大家都没有弄清楚需求就毛毛躁躁的开始了，问服务端他一脸懵逼，问测试她也一脸懵逼，问产品还几乎是一天一个答案变着花的改来改去。 于是我当时直接拉着服务端和测试来着对了两三天的需求，写了很多很多的文档和图例，最后进入了稳定的开发环节，最后我眼里我们这个前期极度混乱的模块完成度和质量也是超于预期的。 有过这样的经历，我有几点经验分享给大家，但是是一家之言，不一定正确： 如果对于一件事没有人主动，不如你主动去推动 相信我，在大家都混乱的时候，你主动出击，大家都会更加的信任你，你会更加的主动，更加的有决策力。 去做（最）了解需求的人 或许很多前端都觉得，服务端给我啥，我渲染啥，对于需求的了解不是那么重要，但是其实完成任务和把一件事情做好是有区别的，当你了解需求，你可以去做到更好的优化和编码，也有助于你增加业务深度。 大胆说话 有想法就说出来，不了解就问出来。憋着不会让你成长，怯懦会丢失机会。问了个很拙略的问题大不了被嘲笑几句，被阴阳怪气几句，然而我认识的大多数人还是很儒雅随和的哈哈哈。 计算机基础，到底要不要学如果了解我的朋友肯定知道，我最近写的技术文基本都是和计算机基础相关的 前端学编译原理（一）：编译引论草系前端手摸手带你实现正则引擎，点燃夏日最热情的烟火🔥 不是因为我自视甚高还是什么的，我其实计算机基础并不好，也是一边学习一边给大家分享，就是因为我觉得这些东西很有必要。 我们作为计算机行业从业者，虽然可能大家觉得编译原理，计算机组成原理，操作系统，计算机网络，算法导论什么的离我们很遥远，但是其实不然，其实都已经融入到我们工作接触的东西的方方面面了。 这里我不展开来说，我先说我推荐先去学的，或者说是至少要去学的两门科目。 算法 数据结构 有个说法是： 程序 = 算法 + 数据结构 算法和数据结构可以说是我们日常工作解决问题离不开的东西，说白了吃饭的家伙。怎么形容呢，我这里的比喻恰不恰当： 我们如果要复用某些能力，可能会把这些能力抽象出来和视图层做解藕。那算法和数据结构就是我们作为计算机从业者可以脱离出编程语言可以复用的解决问题的能力。 整洁编码，是工程师的职业素养我自认为我并不是一个编码习惯多么多么好的人，但是我会想尽力去把我的代码都去做到尽可能的整洁，因为我们要知道一件事，编码是协同工作的过程，也是人与人的交流，不是一个人闷着干，代码不仅会被执行，也会被阅读。 我眼里，入行的第一件事情就是建立良好的编码习惯，保证编码质量是工程师应具备的职业素养，毕竟人人都不想天天读屎山一样的代码，己所不欲，勿施于人，先从自己开始吧。 关于老代码，我的惨痛经历其实最开始，我对编码可读性没什么感觉的，但是我刚刚工作接手的项目，简直就是屎山⛰️，大家想象一下，一个刚刚入职的程序员，其实一张白纸，其实会的东西可能不少，毕竟面经看了一大堆，文档看了一遍又一遍，但是可能实践经历大部分人应该还是很匮乏的，一个老手遇到恶心的代码可能都要抖一抖，当这样一个萌新看到了肯定更加一脸懵逼。 于是我也经历了一段痛苦的经历，读代码读的反胃🤢的经历，这样的痛苦作为一个新生代工程师肯定不能让他重现在我的后来者身上的，于是我便开始了我的探索之路，并发誓： 我的代码要做到的基本点是易于阅读的，是整洁的。 很容易做到并提升巨大的点我说了那么多废话，不说如何提升就还是没啥意义，代码中变量和函数占据了很大的比重，我在这里就简单的介绍一下如何在命名和函数上提升编码整洁度，参考《代码整洁之道》，本章后面还会进行书籍推荐环境🌟。 有意义的命名 所有的命名都要有实际意义，命名会告诉你它为什么存在，它做什么事情，应该怎么用。 避免引起误导，变量方法名和实际意义不符 做有意义的区分，array1和array2这样的名字你告诉我有啥区别 使用读的出来的名称，真的很有效，编程是社交活动，名字要读的出来！ 使用可以搜索的名称，难以搜索的名字会让你难以定位变量或者方法调用等 程序中有意义的数字或者字符串应该用常量进行替换 类名和对象名应为名词或名词词组，方法名应为动词或动词词组 每个概念对应一个词，你可以建立一个术语表参考，要做到统一一致 函数 短小：20封顶最佳 函数要只做一件事 函数参数尽量少 使用具有描述性的函数名 标识参数丑陋不堪，向函数传递布尔值做法并不推荐 函数名是动词，参数是名词，并保证顺序 无副作用，方法不要做方法名语义外的事情 书籍推荐优秀的编码通常具有一定的特性，我们想要编码更加优雅，初期一定是需要一定的准则，而准则可以通过专业的书籍获取。 我曾经专门出过一篇文章，里面讲了我的编码经历和书籍推荐：关于整洁代码与重构的摸爬滚打其实就是以下几本书： 代码整洁之道 重构：改善既有代码设计 代码大全2这我列出的顺序，就是阅读这几本书籍的顺序。因为代码大全2真的是比较难读。 tip: 我那篇文章真的质量不错，推荐大家去看一下，对这几本书都有一些自己的解读和介绍 关于整洁编码，有几句话要说 当你负责一块的代码时，一定要保证你离开的时候比你刚接手的时候更加整洁，即：营地法则 即使无人监督review，你也要认真思考编码，这样会成长的更加快速，尤其是刚刚开始工作的程序员 有注释不是你可以写垃圾代码的借口 开发之前，先进行重构，以让老代码更好的支持你未来的编码 傻瓜都能写出计算机可以理解的代码。唯有能写出人类容易理解的代码的，才是优秀的程序员。… 最后送大家一句话：人自省以明理，代码自省以强健。 一周年了，我与前端有场约会关于未来，无需多言。关于现在，元气满满这是我的纪念文💎，一般我都会在这里展望这展望那🌟，但是其实关于未来的事情，暂时就交给未来，我只是知道现在的我还会元气满满🔥。 我可能前端的基础还不扎实，计算机基础也还是停留在表面，但是我会继续在这里和大家分享，和大家一起学习，在这里记录我的成长，我的故事。 寒草小兄弟，工作一周年快乐鸭🦆继续元气满满哦 听着歌，望着天，骑向火红的云 写这篇文章的时候是 2021-07-22 ，下过一场雨，北京的夕阳格外好看，我骑着车，望着天空，听着歌。 愿大家的未来都红彤彤的～ 我是会陪伴大家一起成长的寒草🍄，一个工作一周年的草系码猿🌳如果大家喜欢我的文章，欢迎点赞 👍 关注 ➕ ，我会更新更多精彩内容","link":"/about/index.html"}],"posts":[{"title":"前端学编译原理（一）：编译引论","text":"作者：寒草微信：hancao97介绍：一个不一样的北漂程序员(工作10个月的年轻程序员)，欢迎加微信批评指正交流技术或者一起玩耍约饭 引言凡事都可以扯一扯情怀在我在开始写文章的那一段时间，我发了这样一篇文章我，24岁，展望一下？里面不仅提到了我的各种离谱的flag，也提到了我的母校，我怀念那段时光，也因整个大四那一年没有在母校度过，因为疫情的原因没有毕业照，没有毕业旅行而十分可惜。但是，我还是记得我在母校度过的美好时光，而编译原理也正是我在那里求学过程中有印象的最后一个专业课。前两天时间，我也在和别人讨论我的js实现按键精灵——尝试前端实现自动化测试（一），在交流探讨过程中，我感受到其实曾经学习过的编译原理也确实在影响着我的思考方向。于是我找回了大学的课件资料，并会结合更多的资料，去完成我的前端学编译原理这个系列： 一方面是对知识的回顾一方面是怀念那曾经在学校里不曾认真听讲，期末突击完成的课（狗头）。 为什么要学编译原理首先介绍一下，我是一名前端工程师，所以在此以前端的视角出发来思考这个问题： 为什么我们要学习编译原理？ 首先我想去纠正一个误区，前端并不是只要去弄好HTML，CSS，JS三大金刚，了解了解各种不同的布局模式，学习一些主流的框架，用一用人家提供好的API，用一下社区成熟的脚手架快速搭建项目就可以了。是这样就能胜任很大部分的前端工作，但是深入学习我们会发现一件可怕的事情，我们会发现在前端这个领域会有层出不穷的各种库，各种工具，各种框架。技术推陈出新，可是万变不离其宗，编译原理作为一个基础理论学科，学习编译原理可以帮助你： 更快更容易的学习新的技术 可以帮助我们更多的了解语言背后的抽象 可以帮助我们用更优雅的形式去描述复杂的模型而且可能所谓编译器更像是一个把源语言变成目标语言黑盒子，所以我们其实对他并没有太大的感知，但是其实它已经渗透在我们日常工作的方方面面了： eslint：代码检查 es6，ts转码工具：Babel（将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法），tsc（用于将TypeScript 转换为 JavaScript 代码） 各种模版引擎（输入模板字符串 + 数据，得到渲染过的字符串）：最早诞生于服务端动态页面的开发，如 JSP、PHP、ASP 等模板引擎，自 Node.js 快速发展以后，前端界又产出了非常多的轮子，包括 EJS、art-template、Pug 、Mustache等等。【个人对模版引擎没什么了解，此处列举的模版引擎来着万能的网友】 CSS预处理器：sass、less等等，让我们从纯css时代的刀耕火种中解放。赋予了前端工程师们更强大的样式编写能力（虽然我可能用到的也只是他们提供的皮毛，但是支持css嵌套真的是深得我心）。 主流框架中的应用：区别于模版引擎，不可将前端框架和模板引擎混为一谈，很多的主流框架都有对编译原理的应用，包括vue，react，angular。 markdown：比如我现在正在掘金写我的文章，左边是markdown语法，右边就可以同步预览最终的展示效果～ … 总结一下：可能我对于学习编译原理的原因描述不是很专业，可能也有我能力所限的原因，也可能是因为我工作年限并没有达到某个地步，但是我希望大家了解的是以下几点： 学习编译原理可以帮助我们更好更快的学习新的技术。 在前端领域，编译原理已经有了大范围的应用，所以想成为一个更加优秀的前端工程师，编译原理也是一项必修课。 学习cs专业的基础理论学科，可以帮助你获得突破，去做一些之前只敢想象的事情。 开始前说点什么我也不知道以我这粗浅的掌握和拙劣的语言功底能否把这样一个较大的课题讲的清楚明白，但是事在人为，我会尽我所能，让这个系列可以在保证正确性的基础之上保持更新，并以我的视角带大家与我一起感受编译之美。之前我也出过很多系列性质的文章：浏览器渲染机制Promise专题如果大家对以上内容有一丢丢兴趣，也欢迎阅读并与我交流探讨，作为刚入行不到一年的新人也期望收到各位大佬各位前辈的批评指正。 ok，闲言少叙，我们进入正题。 程序设计语言和编译程序低级语言基本概念介绍： 包括机器语言和汇编语言机器语言：指的是机器能直接识别的程序语言。无需经过翻译，每一操作码在计算机内部都有相应的电路来完成它，或指不经翻译即可为机器直接理解和接受的程序语言或指令代码。计算机硬件只能识别“断开”和“闭合”两种物理状态，也就是0和1。机器语言使用绝对地址和绝对操作码。不同的计算机都有各自的机器语言，即指令系统，不同型号的计算机其机器语言是不相通的，按着一种计算机的机器指令编制的程序，不能在另一种计算机上执行。从使用的角度看，机器语言是最低级的语言。 操作码：操作码给出指令完成的功能 地址码：地址码给出与操作数相关的地址或者操作数本身 指令 10110110【操作码】 00000000【地址码】 表示进行一次加法操作 指令 10110101【操作码】 00000000【地址码】 表示进行一次减法操作 汇编语言：是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符（Mnemonics）代替机器指令的操操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的,不同平台之间不可直接移植。举个例子，a = a + b的表达方式： MOV AX,1 MOV BX,2 ADD AX,BXps：是不是相较于之前的0和1，现在已经可以大致看懂了？ 优点： 速度快 缺点： 难理解，出错率高，难维护 依赖于具体机器，移植性差 发现： 越是低级的语言对机器越是友好，越是符合机器的思考方式，因此执行效率高。 越是高级的语言对人类越是友好，越是符合人类的思考方式，因此开发效率高。高级语言基本概念形式语言 介绍： 用精确的数学或机器可处理的公式定义的语言。与自然语言对应，自然语言就是人类讲的语言，这类语言不是认为设计，而是自然进化的。形式语言是为了特定的应用而人为设计的语言，存在领域之分，例如数学家用的各种运算符号，化学家用的各种分子式，而编程语言也是一种形式语言，是专门设计用来表达计算过程的形式语言。 特点： 高度的抽象化：采用形式化的手段-专用符号,数学公式-来描述语言的结构关系,这种结构关系是抽象的 是一套演绎系统：形式语言本身的目的就是要用有限的规则来推导语言中无限的句子,提出形式语言的哲学基础也是想用演绎的方法来研究自然语言 具有算法的特点高级语言 介绍： 高度封装了的编程语言，与低级语言相对，它更接近于我们平时正常的人思维，其最大的特点是编写容易，代码可读性好。实现同样的功能，使用高级语言耗时更少，程序代码量更短，更容易阅读。其次，高级语言是可移植的，也就是说，仅需稍作修改甚至不用修改，就可将一段代码运行在不同类型的计算机上。现在大多数人使用的语言，如C、C++、Python、Java、Javascript等等，都属于高级语言。优点： 面向自然表达 更易于学习，易于理解，易于修改 可移植性高 缺点： 运行需要其他程序支撑（编译程序等） 运行速度相比汇编要慢 占用空间相对较多 高级语言与汇编语言程序的执行翻译程序翻译程序可以将一种计算机编程语言编写的程序翻译成另一种计算机语言。输入对象是源程序，一般是由高级语言编写的程序，输出对象是目标程序，可以是机器语言，汇编语言，或者是用户自定义的某种中间语言程序或者是其他的高级语言。翻译程序可以包括： 汇编器（Assembler） 编译器（Compiler） … Linker（链接器）：将 目标文件内容 连同 运行时库程序 合成到一个 计算机能够加载和执行的目标程序 执行方式执行高级语言程序的方式分为三种： 编译方式 解释方式 转换方式下面我来具体介绍～编译方式和解释方式 编译方式解释方式详细介绍这里我先借助知乎网友的例子，这个过程的区别很像是： A是英语演讲者，B是台下的听众，C是翻译官。那么，编译器就是:翻译官把A的演讲的所有内容（等A演讲完）一次性整理好成一份翻译后的文件，发给听众B看。 翻译器就是:翻译官C在A演讲的时候，A讲一句，C翻一句给听众B。 其实这个例子还是很生动形象的，总结起来就是： 编译器是在代码运行之前生成目标平台指令，可脱离编译器独立运行。 解释器在代码运行过程中生成目标平台指令，所以不可以脱离解释器独立运行。 于是我们看到的现象是，编译型语言要先编译再运行，而解释性语言直接“运行”源代码。 即他们的根本区别就是运行时，解释型需要将程序解释成目标平台指令来运行，费了一道手续，而编译型在运行之前就已经让编译器给程序编译成目标平台指令了，所以更快。ps：此处可以结合后面辩证的看 那个段落效果更佳～ 解释器与编译器不同角度对比 着眼点：解释器是执行系统，编译器是转换系统 程序动态修改：解释执行更胜任，编译执行需要动态编译技术，难度较大 速度：解释器较慢 空间开销：解释器开销大 错误诊断：解释器更强，因为解释器会逐个语句的执行源程序 辩证的看 我们不妨换个角度来看，其实如果单纯从编译方式和解释方式的定义出发，他们是那么的水火不相容，然而编译和解释的界限却并没有如此的清晰，举个例子（下文有流程图）：Java需要预先把代码编译成虚拟机指令的，然后在运行这些虚拟机指令，有的教科书上会成为混合型或者半编译型，这样的好处之一是在一台机器上编译得到的字节码可以在另一台机器上解释执行，通过网络就可以完成机器之间的迁移。所以其实我们把他们撕裂着看又有一点点不合理，我查阅资料也发现有很多人对此有不同的见解，其实我眼里，我们高级代码执行，无非是从高级的抽象转化为低层级抽象的一个过程，我们在这个过程中，可能用到了解释器，也可能用到了编译器，这两者的使用并无冲突，就像上面的例子一样，无非是我们可能在降低代码抽象层级的过程中分出了不同的阶段，用了不同的方案而已，无论是编译执行还是解释执行，应该与语言无关，只是使用了什么样的方案把代码让机器看的懂而已，所以纠结一个语言是解释型还是编译型语言在我的认知中是不必要的上一段Java的流程图： 转换方式转换方式我放在最后单独说，因为可能和上述内容有一点点不同： 假如我们要实现L语言 我们现在已经有了L1语言的编译程序 那么我们可以先把用L语言编写的程序转换成等价的L1语言程序 再去利用L1语言的编译程序去实现L语言说白了我们就是利用转换器将没有编译程序的L程序转换成已经存在编译程序的L1语言再去将其转换为目标程序。编译器的结构引言——没有谁是一座孤岛，编译器也一样程序设计语言是向人以及机器描述计算过程的记号，这个世界依赖于程序设计语言，因为在所有计算机上运行的所有软件都是用某种程序设计语言编写的，但是，在一个程序可以运行之前，他需要先被翻译成计算机可以执行的形式。做这个翻译工作的就是编译器。简单来讲，编译器就是一个程序，他可以阅读某一种语言编写的程序，并把该程序翻译成为一个等价的、用另一种语言编写的程序。——引自《编译原理（第二版）》第一章引论部分 编译器的基本任务：将源语言程序翻译成等价的目标语言程序上文中引言可能也会造成些许理解误差，把源语言程序转换成计算机可执行文件有可能不完全是编译器独自完成的，编译器并不是孤军奋战，他也有很多同伴与之携手一同把源代码转换成机器上的可执行文件，在上一章对翻译程序的介绍中我们说过，翻译程序可能有很多部分组成，编译器可能只是其中一部分。创建一个可执行的目标程序可能还需要一些其他程序： 预处理器：一个源程序很可能被分成多个模块，并存放在独立的文件中，预处理器可以把源程序聚合在一起，同时还负责把那些称为宏的缩写转换为源语言的语句。 编译器：将源语言程序翻译成等价的目标语言程序（可能产生汇编程序作为输出，因为汇编语言比较容易输出和调试） 汇编器：将汇编程序转换为可重定位机器代码 链接器：大型程序经常被分成多个部分进行编译，因此可重定位的机器代码有必要和其他可重定位的目标文件以及库文件链接在一起，形成真正的机器上运行的代码。链接器就是解决外部内存地址引用的问题。 加载器：把所有可执行目标文件放在内存中执行OK，我们介绍了编译器和编译器的伙伴，那么接下来一起窥探一下编译器神秘表象下的内部结构吧。编译器内部结构概览在我么开发者视角上，我们写完代码，之后之间编译运行，其实更多的时候对于编译器是无感知，可能更多的时候点击运行，之后呐喊link start！代码就跑起来了，当然估计没什么人会像这样有仪式感（其实正常人称呼这样的行为是中二）。所以编译器对于我们就像是一个黑盒子，我们把这个盒子打开一点，就可以看到里面包含两个部分： 分析部分 综合部分经常分析部分被称为前端，综合部分被称作后端。分析部分（前端）分析部分把源程序分解成多个组成要素，并在这些要素之上加上语法结构。然后，它使用这个结构创建该程序的中间表示。当然在这个阶段如果检查出程序的语法错误，或者语义不一致，就必须提供有用的信息，使得用户可以将其改正。 分析部分还会收集有关源程序的信息，并把信息存放在一个称为符号表的数据结构中（后期寒草：“符号表在后面也会多次提到哦～”）。符号表和中间代码表示会作为综合部分的输入。 综合部分（后端）综合部分根据中间表示和符号表中的信息来构造用户期待的目标程序。 编译器分步骤介绍在上一段我们把编译器分成了两个阶段：前端和后端。但是如果我们能加详细的研究编译过程，会发现他会顺序执行一组步骤，一个典型的把编译原理分解成多个步骤的方式下面两个图片。当然在实践中，多个步骤可能会被组合在一起，而组合在一起的步骤之间的中间表示不需要被明确构造。存放整个源程序的信息的符号表可以由编译器的各个步骤使用。 其中为了综合部分（后端程序）可以生成更好的目标程序，如果基于未经过优化的中间表示来生成代码，则代码质量会受到影响，所以可能会加入代码优化阶段。图中的两个代码优化阶段可以被省略。 所以我们进行一个简要的总结，其实整个步骤可以大致描述为以下几个阶段： 词法分析 语法分析 语义分析 中间代码生成 中间代码优化 目标代码生成词法分析介绍编译器的第一个步骤是词法分析，词法分析的输入是源程序的字符序列。识别每一个单词及其种类，并将其表示成TOKEN形式： tip: 词法分析阶段不依赖于语言的语法定义 词法分析的结果是语法分析的输入 词法分析还可以做到： 检测标识符拼写错误 去掉代码中的注释举例举个例子大家可能就懂了： 12float sum, first;sum = first + 10; 上面是一段简单的代码，那么我们进行词法分析： 可能实现的话有差异，此处为了大家可以理解的更加清楚，所以一切从简，但是我们依然可以按照这个来理解，我想大家可能看完例子，就大概明白了这个过程。 为什么第一个sum变成了标识符 1 呢，其实标识符后面对应的值其实指向了符号表的引用，后面first对应2也是这个道理 词素：语法功能的最小单位，上面 float，sum，first，+ 等都是一个词素。 语法分析介绍语法分析是编译器的第二个步骤，语法分析会使用词法分析生成的TOKEN序列，并依据源语言的语法规则生成树形的中间表示。该中间表示给出了词法分析产生的词法单元流的语法结构。 tip： 分析时如果发现错误，则输出错误的位置以及类型 未发现错误则将语法分析的输入（词法分析的输出）转换为树形中间形式，常用的方法是语法树 语法树：树中的每个内部节点表示一个运算，而该节点的子节点表示该节点的子节点表示该运算的分量。输入： 当词法分析程序时语法分析程序的子程序时：输入为源程序的字符序列 当词法分析是独立的：输入是TOKEN序列举例继续前面词法分析的例子来看。首先我们的例子还是sum=first+10。他所对应的词法分析TOKEN序列是：&lt;标识符，1&gt; &lt;运算符，=&gt; &lt;标识符，2&gt; &lt;运算符，+&gt; &lt;整形常量，10&gt; &lt;分隔符，；&gt; 其中 1对应sum，2对应first。 语义分析介绍编译器的第三个步骤是语义分析，该能力由语义分析器提供，语义分析器使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。它同时收集类型信息，并把这些信息存放在语法树或者符号表中，以便在随后的中间代码生成过程中使用。于是语义分析器的作用为： 审查源程序是否有语义错误 为代码生成收集类型信息 类型检查：类型检查是语义分析的重要组成部分，编译器检查每个运算符是否具备匹配的运算分量，比如： 数组的下标必须是整数，浮点数作为下标会报错。 条件表达式必须是布尔型 赋值语句左右两边类型是否相融 … 自动类型转换：某些程序设计语言会允许某些类型转换，那么在语义分析阶段也会进行自动类型转换，比如： 一个二元运算符可以应用于一对整数或者一对浮点数。那么该运算符如果应用于一个浮点数和一个整数，那么这个整数可能被自动转换成浮点数。 举例语义错误请看注释： 1234float sum, first;sum = first + 10;count = sum; //count无定义first = sum % 10;//sum是浮点型，不能进行取余数运算 中间代码生成介绍在把一个源程序翻译成目标代码的过程中，一个编译器可能构造出一个或者多个中间表示，这个中间表示可以有多种形式。 语法树就是一种中间表示形式，在语法分析和语义分析中使用。 在语法分析和语义分析完成之后，很多编译器会生成一个明确的低级或者类机器语言的中间表示。这个中间表示应该具备两个重要的性质： 易于生成 可以轻松的翻译为目标机器上的语言 当然这个中间代码可能存在很多种形式： 后缀式（栈式）中间代码 三地址中间代码（三元式和四元式） 图结构的中间代码（树，DAG） 举例代码： 12float sum, first, count;sum = first + count * 10; 中间代码（四元式）： 1234(int-to-float, 10, , t1)(*, count, t1, t2)(+, first, t2, t3)(=, t3, , sum) 简单解释一下： 真正的中间代码里其中的count，first这种会表示成符号表中的引用。 (*, count, t1, t2)以这个为例子含义是 t2 = t1 * count 关于三地址指令： 每个三地址赋值指令右部最多只有一个运算符，因此这些指令顺序确定了运算的顺序 编译器应该生成一个临时名字以存放一个三地址指令计算得到的值（t1，t2…） 有些三地址指令的运算分量少于三个，比如上面中间代码的第一条和最后一条。 代码优化介绍目的：改进中间代码，意图生成更好的目标代码。 更好通常意味着更快，但是也可能会有其他目标，比如更短的或者能耗更低的代码。 不同的编译器在代码优化过程所做的工作量可能相差很大，那些优化工作做的很多的编译器（即所谓的优化编译器）会在优化阶段花费相当多的时间，有些简单的优化方法可以极大的提高目标程序的运行效率而不会过多的降低编译速度。 常见的优化方式： 常量表达式优化 公共子表达式优化 不变表达式的循环外提 削弱运算强度 …举例中间代码（四元式）： 1234(int-to-float, 10, , t1)(*, count, t1, t2)(+, first, t2, t3)(=, t3, , sum) 常量表达式优化： 123(*, count, 10.0, t2)(+, first, t2, t3)(=, t3, , sum) 目标代码生成介绍代码生成器以源程序的中间表示形式（中间代码）为输入，并把他映射为目标语言。如果目标语言是机器代码，那么： 必须为程序使用的每个变量选择寄存器或者内存位置。 然后，中间指令被翻译成为能够完成相同任务的机器指令序列。 代码生成的一个至关重要的方面是合理分配寄存器以及存放变量的值。 举例源程序： 12float sum, first, count;sum = first + count * 10; 汇编代码： 12345MOV count, R1MULT R1, #10.0MOV first, R2ADD R1, R2MOV R1, sum 章节小结根据前文介绍，编译器大体可以分为以下几个步骤： 词法分析 语法分析 语义分析 中间代码生成 中间代码优化 目标代码生成后面的文章会对各个步骤的细节进行详细介绍，也会使用小的编译器源码作为例子。下图是《编译原理（第二版）》中的图例，我想大家到这里应该已经对编译器的整个流程有了初步的了解，也可以借助这个图片进行一个简单的回顾～结束语文章中内容来自： 《编译原理（第二版）》 母校课件 经过本人筛选验证的知乎问答 本人的理解（本人理解可能是其中最没有权威可言的部分hhh） 课题内容较多较深，如果存在问题可能无法避免，希望大家不吝赐教，如果存在问题我会积极修正完善～ 在此也希望大家感兴趣可以支持我以前的文章系列：浏览器渲染机制Promise专题…不仅如此，还有很多有趣的内容：寒草的掘金主页我们的github最后！！！少年与爱永不老去，即便披荆斩棘，丢失怒马鲜衣我是寒草间歇性热血，持续性沙雕，希望和大家共同成长，成为一起努力的伙伴微信：hancao97","link":"/2021/07/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"},{"title":"草系前端手摸手带你实现正则引擎，点燃夏日最热情的烟火🔥","text":"大家好，我是寒草😈，一只草系码猿🐒。间歇性热血🔥，持续性沙雕🌟。如果喜欢我的文章，可以关注➕ 点赞 👍，，与我一同成长吧～微信：hancao97 序章对读者的话前一阵，我发了一篇文章前端学编译原理（一）：编译引论，粗略的介绍了一下编译原理这门学科，我也想到一个问题： 单纯枯燥的讲解编译原理这门课程大家可能并不会很接受这系列文章，并且单纯的讲解编译原理肯定有很多人比我讲的要好要细致。 所以我做了这样一个决定：我是一个前端，读我文章的大多数人可能也是前端，所以我不妨接下来将前端的一些应用或者实践和编译原理结合起来。所以这篇文章是本系列的全新实践🌟，如果大家喜欢可以留下你们的点赞👍 或者关注➕，你们的支持是我更文的最大动力🔥。 本篇文章，我将从自动机出发，扩展到我们常用的正则匹配，最后我也会带着大家亲手实现一个简单的正则匹配。干货满满，也会有一己之言，如果大家有疑问或者指正请留在评论区，我会仔细阅读。 仓库地址：js-regular，照例放出仓库的地址，请各位大佬忽视我没写gitignore不小心把node_modules上传上来了，失误，纯属失误 文章大纲 有限自动机基础：DFA与NFA 正则原理浅析 手摸手，带你实现简易版正则引擎和文章目录一致，其中如果不阅读第一章自动机科普，也可以直接跳转到第二章开始阅读，但是推荐全文阅读， 因为第一章也干货满满， 第一章过于生硬的地方我也有举例说明或者用更加接地气的手段做了描述总结✨，以获得完整的思考体验，感受一遍我完整学习实践的过程，属于正则的那如烟火🔥 般绚烂的夏日诗篇也会徐徐展开。 那么我们咸盐少许（闲言少叙），开始我们的正篇吧～ 有限自动机基础章节引论—有限自动机（FA） tip: 如果看不懂特点和形式定义中的话，请大家移步后面我来总结一下部分，帮助大家对有限自动机的定义有一个粗略的理解。 首先在开始下面的话题之前，我们有必要去了解一下，什么是有限自动机， 有限自动机也被称为：时序机。 有限自动机有以下特点： 系统具有有限个状态，不同的状态代表不同的意义。按照实际的需要，系统可以在不同的状态下完成规定的任务。 我们可以将输入字符串中出现的字符汇集在一起构成一个字母表。系统处理的所有字符串都是这个字母表上的字符串。 系统在任何一个状态下，从输入字符串中读入一个字符，根据当前状态和读入的这个字符转到新的状态。 系统中有一个状态，它是系统的开始状态。 系统中还有一些状态表示它到目前为止所读入的字符构成的字符串是语言的一个句子。 有限自动机的形式定义： 有限状态自动机是一个五元组 M=(Q, Σ, δ, q0, F)，其中： Q——状态的非空有穷集合。∀q∈Q，q称为M的一个状态。 Σ——输入字母表。 δ —— 状态转移函数，有时又叫作状态转换函数或者移动函数，δ：Q×Σ→Q，δ(q,a)=p。 q0 —— M的开始状态，也可叫作初始状态或启动状态。q0∈Q。 F —— M的终止状态集合。F被Q包含。任给q∈F，q称为M的终止状态 我来总结一下： 大家不要被上面列出的一大堆定义和特点绕晕，其实总结起来非常简单： 首先有限状态机有一个开始状态，具一个不太恰当的例子：比如说你要提交一个工单，你会经历直属领导审批，人事审批，老总审批几个阶段。那么提交工单就是这个工单系统的有限自动机的开始状态，对应五元组里面的q0 当然，除了开始状态我们还有一个结束状态，那么对于我们提交工单这个流程来讲，我们的结束状态就是工单成功或者工单结束，大家可以发现这个有限自动机具有两个终止状态，所以终止状态是一个集合，并不一定只有一个结束状态，这个结束状态就是五元组里面的F 还有我们有限自动机有限两个字很重要，有限指的是具有有限个状态，就像我们下图中的提交工单,待上级领导审批，待人事审批，待老总审批， 工单成功， 工单失败就是我们的状态集，即五元组中的Q 那么作为自动机，我们该怎么知道我们的下一个状态是啥呢，所以其实我们需要两个东西，一个是现在的状态，一个是状态转移函数δ，比如：我们现在的阶段是人事审批，我们的输入其实就是人事审批，经过状态转移函数（审批结果判断）之后我们就可以得到下一步的状态，状态可能是工单失败或者待老总审批。 不知道经过我的举例之后，大家有没有对定义有了一定的理解，其实总结起来很简单，其实： 有限自动机 = 有限的内部状态集合 + 一组控制规则 DFA — 确定有限自动机定义前文我们已经了解了有限自动机，那么确定有限自动机有哪些特别的点呢，下面我们来看一下确定有限自动机的定义： 确定有限自动机M为一个五元组 M = ( S, ∑, s0, f, Z) S:一个有穷状态集，它的每个元素称为一个状态; ∑:一个有穷字母表，它的每个元素称为一个输入字符; s0∈S:唯一的初始状态(开始状态); f:状态转换函数:S×∑→ S，且单值函数，f(Si,a)=Sk。当前状态Si，遇输入字符a时，自动机将唯一地转换到状态 Sk，称Sk为 Si的一个后继状态; Z⊆S:终止状态集(可接受状态集、结束状态集) 其中每个元素称为终止状态(可接受状态、结束状态), Z可空. 我来总结一下： 我们其实可以和上面的形式定义做一个比较，我们会发现一些很重要的点： 初始状态唯一 状态转换函数是单值函数 终止状态集Z可以为空 举个例子123456789M=({S,U,V,Q}, {a, b}, f, S, {Q}), 其中f定义为：f(S, a)=U f(S, b)=Vf(U, a)=Q f(U, b)=Vf(V, a)=U f(V, b)=Qf(Q, a)=Q f(Q, b)=Q 那么我们就可以画出它对应的自动状态机 DFA接受的字符串 对于 ∑ 中任何字符串t，若存在一条从初始结点到某一终止结点 的路径，且这条路上所有弧上的标记符连接成的字符串等于t， 则称 t 可为DFA M所接受 若DFA M的初始状态同时又是终止状态，则空字符串可为DFA M所接受. DFA M 所能接受的字符串的全体记为L(M) 再次举个例子说明，如果一个自动机是这样的： 那么：L(M1) = { aba, abaa, abab, abaab,…}大家有没有发现，正则匹配的雏形已经有了🌟 DFA的确定性那么我们为什么说 DFA 是确定有限自动机呢，确定这两个字体现在哪里呢？ 初始状态唯一 状态转换函数f: S×∑→S是一个单值函数，即对任何状态s∈S，输入 符号a∈∑， f(S, a)唯一确定下一状态. DFA如何代码实现比如自动机如图所示： 其实我们想要实现简易的 DFA 自动机可以借助 swicth case 实现 1234567891011// 简单写个switchswitch (currentChar) { case 'a': goto Lj; break; case 'b': goto Lk; break; default: throw err;} NFA — 非确定有限自动机定义非确定有限自动机M为一个五元组 M = ( S, ∑, S0, f, Z) S: 一个有穷状态集，它的每个元素称为一个状态; ∑: 一个有穷字母表，它的每个元素称为一个输入字符; S0 ⊆ S: 非空初始状态集; Z⊆S: 终止状态集; f : 状态转换函数，是从S×(∑∪{ε}) 到 S 子集的映射，即S×(∑∪{ε})→ 2^S 注意，这里的后继状态不是单一状态，而是状态集S的子集, 即转换函数不是单值. 我这里总结一下，大家看区别就是状态转换函数的结果不再是单值了, 起始状态也这是一个集合而不是一个确定的值，以及转换函数的的输入是∑∪{ε}就表示有向弧上面的标记可以是空。 举个例子1234NFA M = ({0, 1, 2}, {a, b}, f, {0}, {2})状态转换函数如下：f(0,a)={0,1} f(1,a)=∅ f(2,a)={2}f(0,b)={0} f(1,ε)={2} f(2,b)={2} 那么我们就可以画出它对应的有限自动机 NFA接受的字符串设M是一个NFA，M=(S, ∑, f, S0, Z)，则定义L(M)为从任意初始 状态到任意终止状态所接受的字符串的集合，我们拿上面的自动机举例。上面自动机接受的字符串集合是：L(M) = { β | β是形如…a…的由a, b构成的字符串 } 比如：aaa, bab, abaa… DFA 与 NFA 对照那在本章结束之前，我们回顾一下～ DFA： 开始状态唯一 状态转换函数为单值函数 NFA： 开始状态是一个状态集合 状态转换函数的结果是一个集合 有向弧上面的标记可以是空 更多扩展内容 tip: 此处还会很多值得讲的内容，比如 NFA 到 DFA 的转换, DFA的化简等，但是因为文章内容有限，而且与本文主题关系不大，感兴趣的人可以留言，我们继续开坑。当然我也更加鼓励大家自我学习。 正则原理浅析 本章节部分内容参考：正则表达式引擎执行原理——从未如此清晰！，这篇文章也有很多可以了解的内容大家也可以去围观一下，我从这篇文章学到很多，总结整理的很好。 前文我们已经讲解过了 DFA 和 NFA，即确定有限自动机和非确定有限自动机，根据前面的铺垫想必各位大佬已经可以将正则引擎与自动机关联起来了，而正则引擎大体也可以分成这样的两大类，即：DFA 正则引擎和 NFA 正则引擎。 DFA引擎举个例子我们直接举一个比较简单的例子： 正则表达式是 a[db]c待匹配的字符串是 abc 此处我们使用‘[]’的原因是第三章手摸手，带你实现简易版正则引擎我们将会去实现‘[]’ 下面我们开始匹配： 不知道大家有没有理解，我描述一下对比的过程： 第一次是字符 a 和正则表达式 a 比较 匹配成功后，是字符 b 同时比较表达式中的 b 和 d 再次匹配成功，字符 c 和正则表达式 c 比较 匹配成功 这里面我们值得注意的点是，第二次匹配是 b 同时和 b， d 进行比较，所以可能会消耗更多的内存。 特点我们从上面的例子可以看出一些DFA正则引擎的特点： 文本主导：按照文本顺序执行，所以保证了DFA正则引擎的确定性 记录当前所有有效可能：正如前文示例中的第二次匹配一样，同时比较了 b 和 d ，所以需要消耗更大的内存 每个字符只检查一次：提高了执行效率，因为没有回溯操作重复匹配的过程 不能使用反向引用等功能：因为每个字符只检查一次，只记录当前比较值，所以不能使用反向引用、环视等一些功能 NFA引擎举个例子例子还是刚才的例子，方便大家对照： 正则表达式是 a[db]c待匹配的字符串是 abc 下面我们开始匹配： 这里和前面的DFA模式做一下对比，我们会发现区别，NFA引擎在匹配之前会记录字符的位置，然后选择其中一个可能状态进行匹配，如果匹配失败，会进行回溯，进入其他分支进行匹配。 特点我们从上面的例子可以看出一些NFA正则引擎的特点： 文表达式主导：按照表达式的一部分执行，如果不匹配换其他部分继续匹配，直到表达式匹配完成。 会记录某个位置：我们看到当执行到[db]时，NFA引擎会记录字符的位置，然后选择其中一个先匹配。 单个字符可能检查多次：我们看到当执行到[db]时，比较d后发现不匹配，于是NFA引擎换表达式的另一个分支b，同时文本位置回溯，重新匹配字符’b’。这也是NFA引擎是非确定型的原因，同时带来另一个问题效率可能没有DFA引擎高。 可实现反向引用等功能：因为具有回溯这一步，所以可以很容易的实现反向引用等一些功能！ 对比 章节小结本章结束大家已经获得了所有前置知识🌟，下面我们会利用这些知识去亲手实现一个简单的正则，也是本文的重点，下面我们一起进入下一章的内容吧📖 手摸手，带你实现简易版正则引擎章节序言功能介绍： 入口方法介绍：我们要提供一个方法，testReg，参数有两个，一个是待验证的字符串str，另一个是正则表达式reg，返回一个布尔值，即是否匹配 正则表达式规则介绍： 这个正则表达式要以 ^ 开头，以 $ 结尾 [] 表示匹配字符集合中的一个字符，[] 后可以接 * 或者 + * 表示匹配 0 个或者 0 个以上多个 + 表示匹配 1 个或者 1 个以上的多个 1234// 正则表达式举例^[123]*mn[ab]+cd$^a[ab]+$... 仓库地址：js-regular 思路解析我们遇到一个问题，需要先思考，有了思路之后再进行编码，避免重复修改导致代码的混乱以及时间的浪费。 那么，我们首先要思考我们的目标是啥，既然我们本篇文章的主题是自动机，也没必要卖关子， 我们第一步想到的肯定是， 把正则表达式转换成自动机， 之后借助这个正则匹配的自动机去匹配我们的字符串。 那么我们如何把一个正则表达式转换成一个自动机呢？我的思路是这样的： 123graph TD正则表达式 --&gt; 具有匹配含义的独立单元序列 具有匹配含义的独立单元序列 --&gt; 正则匹配自动机 我来简单解读一下，我会把这个问题分成两部分，首先我需要解析字符串，之后转换成具有匹配含义的独立单元序列，即 TOKEN 序列。什么叫做具有匹配含义的独立单元序列呢？ 我举个例子： 正则表达式是 ^[123]+[a]*3$ ， 那么其它可以分成三个独立单元即： [123]+ [a]* 3但是我肯定不会只是拆成三个字符串，我还是会变成三个具有含义的对象(便于生成自动机)，但是这都是后话了。 之后我们要把 具有匹配含义的独立单元序列（我真的是起名鬼才🐶）转换成自动机，既然我们都说了我会用对象表示每个独立单元， 那最简单的方法就是在这个对象中加入 next 属性， 当然 next 可能是一个数组， 存储着所有可能的分支。 之后我们再写一个方法， 让自动机跑起来就好了。 ok，说干就干，下面我们将进入代码分步骤展示与解读环节，请大家跟着我一起思考。 入口方法 - testReg12345678910// the entry functionconst testReg = (str, reg) =&gt; { if (!reg.startsWith('^') || !reg.endsWith('$')){ // it's not a right reg string throw Error('format mismatch！'); } const generator = getGeneratorStart(reg); return isMatch(str, generator); //console.log(matchStructure)} 入口方法很直白， 大家看我这里接受两个参数， 第一个 str 是待匹配的字符串， 第二个 reg 是正则表达式。 首先我对正则表达式做了验证，如果正则表达式不以 ^ 开头，以 $ 结尾， 表示这个表达式是无效的，是不合法的。 之后我们调用了 getGeneratorStart 方法获取了自动机的开始状态， 之后调用 isMatch 方法对字符串进行一个匹配。 获取自动机方法 - getGeneratorStart1234567// use reg to get generator and return start Pattern Objectconst getGeneratorStart = (reg) =&gt; { const regStr = reg.slice(1, reg.length - 1); const patternObjList = getPatternObjList(regStr); const generator = getGenerator(patternObjList); return generator;} 又是一个很短很直白的方法， 第一步我们对正则表达式做了一个截取，掐头去尾（去掉开头的 ^ 和结尾的 $ ），留下真正有效的部分。之后我们又调用了两个方法 getPatternObjList 和 getGenerator 。这两个方法和之前我在思路解析中表达的一致: getPatternObjList: 输入是 regStr ，即正则表达式字符串，输出是 具有匹配含义的独立单元序列 getGenerator: 输入是前一步的输出，即具有匹配含义的独立单元序列，输出是自动机的起始状态。 获取单元序列方法 - getPatternObjList12345678910111213141516171819202122232425262728293031323334353637383940414243444546// change reg String to Pattern Ojects and return listconst getPatternObjList = (regStr) =&gt; { const len = regStr.length; let patternObjlist = []; let isInCollection = false; let collection = []; // used to store current collection for (let i = 0; i &lt; len; i++) { const char = regStr[i]; if (!isInCollection) { // if (char != '[') { // single char object patternObjlist.push({ isCollection: false, pattern: [char], next: [] }) } else { // char === [ we need to change isInCollection to true isInCollection = true; } } else { if (char != ']') { collection.push(char); } else { // ] is the sign end of collection isInCollection = false; // collectionSign maybe * or + let collectionSign = regStr[i + 1]; let collectionType = 'COMMON'; if( collectionSign &amp;&amp; collectionTypes.includes(collectionSign) ){ collectionType = collectionSign i++; } patternObjlist.push({ isCollection: true, pattern: collection, collectionType, next: [] }) collection = []; } } } return patternObjlist;} 这个方法比较长，但其实就是字符串的一遍遍历， 其实看上去比较简单， 但是值得注意的是我把具有匹配含义的独立单元序列转换成的数据结构： [] 集合对应的数据结构123456{ isCollection: Boolean, pattern: Array, collectionType: emun, next: Array} 正常字符串对应的数据结构 12345{ isCollection: Boolean, pattern: Array, next: Array} 其中 pattern 存储着所有可能的匹配，比如 [123]+ 这个 pattern 就是 [1, 2, 3] collectionType 存储着是 * 还是 + 还是 COMMON，方便后续生成自动机时处理 我给大家演示一下方法的输入输出： 12345678910111213141516171819202122输入：^[123]+[a]*3$输出：[ { isCollection: true, pattern: [ '1', '2', '3' ], collectionType: '+', next: [] }, { isCollection: true, pattern: [ 'a' ], collectionType: '*', next: [] }, { isCollection: false, pattern: [ '3' ], next: [] }] 单元序列转换为自动机方法 - getGenerator1234567891011121314151617181920// change pattern list to regular generatorconst getGenerator = (patternObjList) =&gt; { patternObjList.push({ isEnd: true, }) // the end signal of generator let start = { isStart: true, next:[] }; // generator need a 'start' to start valid const len = patternObjList.length; start.next = getNext(patternObjList, -1); for(let i = 0; i &lt; len; i++ ){ const curPattern = patternObjList[i]; curPattern.next = getNext(patternObjList, i) if(collectionTypes.includes(curPattern.collectionType)){ curPattern.next.push(curPattern); } } return start;} 我们先给 getPatternObjList 方法返回值数组加入起始状态和结束状态。之后我们给起始状态的 next 初始化，之后循环遍历数组，为数组的每一项的 next 初始化，这样就通过 next 中存储的指针将自动机的各个状态串联起来了。 注意：这里 next 数组的每一项都是 patternObjList 数组中对象的引用。以及最后如果 collectionType 是 * 或者 + 还要把自己追加进去，这类的节点可以自循环 之后我们看一下其中的子方法 getNext ，我就不单独开一个章节了，因为这两个方法关联性很强。 1234567891011121314// get PatternObj's nextconst getNext = (patternObjList, index) =&gt; { let next = []; const len = patternObjList.length; for(let i = index + 1; i &lt; len; i++){ const nextPattern = patternObjList[i] next.push(nextPattern) if(nextPattern.collectionType != '*'){ // * need to handle, * is possible no break; } } return next;} 其实最关键就是处理 * ，因为 * 表示 0 个或者 0 个以上的多个，就要继续往后遍历。 比如 a[b]*c 这样的正则表达式，a 后面跟的可能是 b 也可能是 b 后面的 c 最后我们可以看一下这个自动机的输出 123456789101112131415输入：^[123]+[a]*3$输出：// 这里因为可能有循环引用的关系，所以输出会有问题，但是大家也可以通过这个结构一窥究竟{ isStart: true, next: [ { isCollection: true, pattern: [Array], collectionType: '+', next: [Array] } ]} 自动机图例展示输入：^[123]+[a]*3$图例： 验证匹配方法 - isMatch1234567891011121314151617181920212223242526// use generator to test stringconst isMatch = (str, generator) =&gt; { if(generator.isStart){ // the start of recursive for(const nextGen of generator.next){ if(isMatch(str, nextGen)) return true; } return false; } else if(generator.isEnd){ // if generator is end but str is not end return false return str.length ? false : true; } else { if(!str.length){ return false; } if(!generator.pattern.includes(str[0])) { return false; } else { const restStr = str.slice(1); for(const nextGen of generator.next){ if(isMatch(restStr, nextGen)) return true; } return false; } }} 这里其实就是一个递归程序： 如果自动机的当前处于起始状态：不进行匹配，循环匹配 next，只要有一条分支匹配成功，就是合法字符串 如果自动机的当前处于结束状态：判断方法传入的 str 长度是否是 0 ，如果是 0 则表示待匹配字符串也匹配完成了，是合法字符串，反之不合法。 其他情况：匹配当前字符是否在 pattern 数组中，如果在就表示当前字符匹配，继续循环匹配 next，只要有一条分支匹配成功，就是合法字符串于是这样我们的代码就完成了！ 输出演示 结果正确🌟 完整代码方便大家复制粘贴或者完整回顾，是不是很贴心❤️ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131const collectionTypes = ['*', '+'];// change reg String to Pattern Ojects and return listconst getPatternObjList = (regStr) =&gt; { const len = regStr.length; let patternObjlist = []; let isInCollection = false; let collection = []; // used to store current collection for (let i = 0; i &lt; len; i++) { const char = regStr[i]; if (!isInCollection) { // if (char != '[') { // single char object patternObjlist.push({ isCollection: false, pattern: [char], next: [] }) } else { // char === [ we need to change isInCollection to true isInCollection = true; } } else { if (char != ']') { collection.push(char); } else { // ] is the sign end of collection isInCollection = false; // collectionSign maybe * or + let collectionSign = regStr[i + 1]; let collectionType = 'COMMON'; if( collectionSign &amp;&amp; collectionTypes.includes(collectionSign) ){ collectionType = collectionSign i++; } patternObjlist.push({ isCollection: true, pattern: collection, collectionType, next: [] }) collection = []; } } } return patternObjlist;}// get PatternObj's nextconst getNext = (patternObjList, index) =&gt; { let next = []; const len = patternObjList.length; for(let i = index + 1; i &lt; len; i++){ const nextPattern = patternObjList[i] next.push(nextPattern) if(nextPattern.collectionType != '*'){ // * need to handle, * is possible no break; } } return next;}// change pattern list to regular generatorconst getGenerator = (patternObjList) =&gt; { patternObjList.push({ isEnd: true, }) // the end signal of generator let start = { isStart: true, next:[] }; // generator need a 'start' to start valid const len = patternObjList.length; start.next = getNext(patternObjList, -1); for(let i = 0; i &lt; len; i++ ){ const curPattern = patternObjList[i]; curPattern.next = getNext(patternObjList, i) if(collectionTypes.includes(curPattern.collectionType)){ curPattern.next.push(curPattern); } } return start;}// use reg to get generator and return start Pattern Objectconst getGeneratorStart = (reg) =&gt; { const regStr = reg.slice(1, reg.length - 1); const patternObjList = getPatternObjList(regStr); const generator = getGenerator(patternObjList); return generator;}// use generator to test stringconst isMatch = (str, generator) =&gt; { if(generator.isStart){ // the start of recursive for(const nextGen of generator.next){ if(isMatch(str, nextGen)) return true; } return false; } else if(generator.isEnd){ // if generator is end but str is not end return false return str.length ? false : true; } else { if(!str.length){ return false; } if(!generator.pattern.includes(str[0])) { return false; } else { const restStr = str.slice(1); for(const nextGen of generator.next){ if(isMatch(restStr, nextGen)) return true; } return false; } }}// the entry functionconst testReg = (str, reg) =&gt; { if (!reg.startsWith('^') || !reg.endsWith('$')){ // it's not a right reg string throw Error('format mismatch！'); } const generator = getGeneratorStart(reg); return isMatch(str, generator); //console.log(matchStructure)}console.log(testReg('2131aa3', '^[123]+[a]*3$')); 章节小结本章我们用前面几章所学的知识实现了一个简易的正则🌟，当热真正的正则引擎要复杂的多的多，也会有预编译等我还没有接触过的流程。但是文章领进门，修行还是在个人的，相信大家与我一同完成这个简易的正则匹配之后也会获得一些解决问题的思路，或者多了一些思考，感谢大家与我一起体验这个过程，不妨点个赞呀👍 ，或者关注➕ 给我更大的动力，与你们一起学习成长。 结束语 正则原理浅析章节部分内容参考：正则表达式引擎执行原理——从未如此清晰！ 感谢前辈的分享。感谢母校吉林大学的教材课件～感谢作者大佬洛竹有关某些特殊内容🐶的经验分享～感谢运营姐姐少女骑士的抱枕，让我战斗力满满～ 最后，我是寒草，一只草系码猿🐒，，大家喜欢我的文章不妨关注➕ ，点赞👍 。你们的支持是我最大最大最大的动力～ 乾坤未定，你我皆是黑马🔥葱鸭🦆","link":"/2021/08/01/%E6%AD%A3%E5%88%99%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"},{"name":"状态机","slug":"状态机","link":"/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"计算机基础","slug":"计算机基础","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"编译原理","slug":"编译原理","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"categories":[{"name":"前端与编译原理","slug":"前端与编译原理","link":"/categories/%E5%89%8D%E7%AB%AF%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]}